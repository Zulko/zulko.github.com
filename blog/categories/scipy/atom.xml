<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scipy | __del__( self )]]></title>
  <link href="http://Zulko.github.io/blog/categories/scipy/atom.xml" rel="self"/>
  <link href="http://Zulko.github.io/"/>
  <updated>2013-11-09T15:27:38+01:00</updated>
  <id>http://Zulko.github.io/</id>
  <author>
    <name><![CDATA[Zulko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Delay differential equations in Python]]></title>
    <link href="http://Zulko.github.io/blog/2013/10/22/delay-differential-equations-in-python/"/>
    <updated>2013-10-22T07:50:00+02:00</updated>
    <id>http://Zulko.github.io/blog/2013/10/22/delay-differential-equations-in-python</id>
    <content type="html"><![CDATA[<p><em>I wrote a simple method to solve delay differential equations (DDEs) in Python, using the Python package Scipy.</em></p>

<p>As usual the code is available at the end of the post :).</p>
<h2>Example 1 : Sine</h2>
<p>I start with an example whose exact solution is known so that I can check that the algorithm works as expected. We consider the following equation:</p>

<p>$latex y(t) = sin(t) \ \ \ for\ \ \ t &lt; 0$</p>

<p>$latex y’(t) = y(t-3\pi/2) \ \ \ for\ \ \ t \geq 0$</p>

<p>The trick here is that $latex sin(t-3\pi/2) = cos(t)=sin’(t)$ so the exact solution of this equation is actually the sine function.</p>

<div style="font-size: 13px;">[sourcecode language="python"]
from pylab import *

model = lambda Y,t : Y(t - 3*pi/2) # Model
tt = linspace(0,50,10000) # Time start, end, and number of points/steps
g=sin # Expression of Y(t) before the integration interval
yy = ddeint(model,g,tt) # Solving

# PLOTTING
fig,ax=subplots(1)
ax.plot(tt,yy,c='r',label="$y(t)$")
ax.plot(tt,sin(tt),c='b',label="$sin(t)$")
ax.set_ylim(ymax=2) # make room for the legend
ax.legend()
show()
[/sourcecode]

</div>
<p style="text-align: center;"><a href="http://zulko.files.wordpress.com/2013/02/dde_sin1.png"><img class="aligncenter  wp-image-792" alt="dde_sin" src="http://zulko.files.wordpress.com/2013/02/dde_sin1.png" width="425" height="320" /></a></p>
<p>The resulting plot compares our solution (red) with the exact solution (blue). See how our result eventually detaches itself from the actual solution as a consequence of many successive approximations ? As DDEs tend to create chaotic behaviors, you can expect the error to explode very fast. As I am no DDE expert, I would recommend checking for convergence in all cases, i.e. increasing the time resolution and see how it affects the result. Keep in mind that the past values of Y(t) are computed by interpolating the values of Y found at the previous integration points, so the more points you ask for, the more precise your result.</p>
<h2>Example 2 : Delayed negative feedback</h2>
<p>You can select the parameters of your model at integration time, like in Scipy’s ODE and odeint. As an example, imagine a product with degradation rate r, and whose production rate is negatively linked to the quantity of this same product at the time (t-d):</p>

<p>$latex y(t) = 0 \ \ \ for\ \ \ t &lt; 0 $</p>

<p>$latex y’(t) = \dfrac{1}{1+(\dfrac{y(t-d)}{K})^2} -ry(t) \ \ \ for\ \ \ t \geq 0$</p>

<p>We have three parameters that we can choose freely. For K = 0.1, d = 5, r = 1, we obtain oscillations !
&lt;div style="font-size: 13px;"&gt;[sourcecode language=”python”]
from pylab import *</p>

<h1 id="model-with-unknown-parameters">MODEL, WITH UNKNOWN PARAMETERS</h1>
<p>model = lambda Y,t,k,d,r :  1/(1+(Y(t-d)/k)<em>*2) - r</em>Y(t)</p>

<h1 id="history">HISTORY</h1>
<p>g = lambda t:0</p>

<h1 id="solving">SOLVING</h1>
<p>tt = linspace(0,50,10000)
yy = ddeint(model,g,tt,fargs=( 0.1 , 5 , 1 )) # K = 0.1, d = 5, r = 1</p>

<h1 id="plotting">PLOTTING</h1>
<p>fig,ax=subplots(1)
ax.plot(tt,yy,lw=2)
show()
[/sourcecode]</p>

<p>&lt;/div&gt;
&lt;p style="text-align: center;"&gt;<a href="http://zulko.files.wordpress.com/2013/03/dde_negativefeedback.png"><img class="aligncenter  wp-image-815" alt="dde_negativefeedback" src="http://zulko.files.wordpress.com/2013/03/dde_negativefeedback.png" width="431" height="322" /></a>&lt;/p&gt;</p>

<h2>Example 3 : Lotka-Volterra system with delay</h2>
<p>The variable Y can be a vector, which means that you can solve DDE systems of several variables. Here is a version of the famous Lotka-Volterra two-variables system, where we introduce some delay d. For d=0 we find the solution of a classical Lotka-Volterra system, and for d non-nul, the system undergoes an important amplification:</p>

<p>$latex \big(x(t), y(t)\big) = (1,2) \ \ \ for\ \ t &lt; 0, \ \ else$</p>

<p>$latex x’(t) = 0.5x(t)\big(1-y(t-d)\big)<br />
y’(t) = -0.5y(t)\big(1-x(t-d)\big)$
&lt;div style="font-size: 13px;"&gt;[sourcecode language=”python”]
from pylab import *</p>

<p>def model(Y,t,d):
    x,y = Y(t)
    xd,yd = Y(t-d)
    return array([0.5<em>x</em>(1-yd), -0.5<em>y</em>(1-xd)])</p>

<p>g = lambda t : array([1,2])
tt = linspace(2,30,20000)
fig,ax=subplots(1)</p>

<p>for d in [0, 0.2]:
    yy = ddeint(model,g,tt,fargs=(d,))
    # WE PLOT X AGAINST Y
    ax.plot(yy[:,0],yy[:,1],lw=2,label=’delay = %.01f’%d)</p>

<p>ax.legend()
show()
[/sourcecode]</p>

<p>&lt;/div&gt;
&lt;p style="text-align: center;"&gt;<a href="http://zulko.files.wordpress.com/2013/03/dde_lotka.png"><img class="aligncenter  wp-image-848" alt="dde_lotka" src="http://zulko.files.wordpress.com/2013/03/dde_lotka.png" width="456" height="342" /></a>&lt;/p&gt;</p>

<h2>Example 4 : A DDE with varying delay</h2>
<p>This time the delay depends on the value of Y(t) !</p>

<p>$latex y(t) = 1,\ \ \ t \leq 0$</p>

<p>$latex y’(t) = - y\big(t-3\cos(y(t))^2 \big),\ \ \ t &gt; 0 $
&lt;div style="font-size: 13px;"&gt;[sourcecode language=”python”]
from pylab import *
model = lambda Y,t:  -Y(t-3*cos(Y(t))**2)
tt = linspace(0,30,2000)
yy = ddeint(model, lambda t:1, tt)
fig,ax=subplots(1)
ax.plot(tt,yy,lw=2)
show()
[/sourcecode]</p>

<p>&lt;/div&gt;
&lt;p style="text-align: center;"&gt;<a href="http://zulko.files.wordpress.com/2013/03/dde_ydependent.png"><img class="aligncenter  wp-image-807" alt="dde_Ydependent" src="http://zulko.files.wordpress.com/2013/03/dde_ydependent.png" width="424" height="317" /></a>&lt;/p&gt;</p>

<h2>Code</h2>
<h3>Explanations</h3>
<p>The code is written on top of Scipy’s ‘ode’ (ordinary differential equation) class, which accepts differential equations under the form</p>

<p>model(Y,t) = “ expression of Y’(t) “</p>

<p>where $latex Y$, and the output $latex Y’$, must be Numpy arrays (i.e. vectors).</p>

<p>For our needs, we need the input $latex Y$ to be a function of time, more precisely a function that can compute $latex Y(t)$ at any past or present $latex t$ using the values of $latex Y$ already computed. We also need $latex Y(t)$ to return the value of some function $latex g(t)$ if t is inferior to some time $latex tc$ that marks the start of the integration.</p>

<p>To this end, I first implemented a class (ddeVar) of variables/functions which can be called at any time $latex t$: for $t&lt;latex t_c$, it will return the value of $latex g(t)$, and for $latex t&gt;tc$, it will look for two already computed values $latex Y_a$ and $latex Y_b$ at times $latex t_a&lt;t&lt;t_b$, from which it will deduce $latex Y(t)$ using a linear interpolation. Scipy offers many other kinds of interpolation, but these will be slower and won’t support vectors for $latex Y$.</p>

<p>Such variables need to be updated every time a new value of $latex Y(t)$ is computed, so I created a class ‘dde’ that inherits from Scipy’s ‘ode’ class but overwrites its integration method so that our special function $latex Y$ is updated after each integration step. Since ‘ode’ would feed the model with a vector Y (a Numpy array to be precise), which we don’t want, we give to the integrator an interface function that takes a Numpy array Y as an argument, but immediately dumps it and calls the model with our special ddeVar variable Y (I hope that was clear :) ).</p>
<h3>Ok, here you are for the code</h3>
<p>You will find the code and all the examples as an IPython notebook <a href="http://zulko.files.wordpress.com/2013/03/ddes-ipynb.doc">HERE</a> (if you are a scientific pythonist and you don’t know about the IPython notebook, you are really missing something !). Just change the extension to .ipynb to be able to open it. In case you just asked for the code:
&lt;div style="font-size: 13px;"&gt;[sourcecode language=”python”]
# REQUIRES PACKAGES Numpy AND Scipy INSTALLED
import numpy as np
import scipy.integrate
import scipy.interpolate</p>

<p>class ddeVar:
    “”” special function-like variables for the integration of DDEs “””</p>

<pre><code>def __init__(self,g,tc=0):
    """ g(t) = expression of Y(t) for t&lt;tc """

    self.g = g
    self.tc= tc
    # We must fill the interpolator with 2 points minimum
    self.itpr = scipy.interpolate.interp1d(
        np.array([tc-1,tc]), # X
        np.array([self.g(tc),self.g(tc)]).T, # Y
        kind='linear', bounds_error=False,
        fill_value = self.g(tc))

def update(self,t,Y):
    """ Add one new (ti,yi) to the interpolator """

    self.itpr.x = np.hstack([self.itpr.x, [t]])
    Y2 = Y if (Y.size==1) else np.array([Y]).T
    self.itpr.y = np.hstack([self.itpr.y, Y2])
    self.itpr.fill_value = Y

def __call__(self,t=0):
    """ Y(t) will return the instance's value at time t """

    return (self.g(t) if (t&lt;=self.tc) else self.itpr(t))
</code></pre>

<p>class dde(scipy.integrate.ode):
    “”” Overwrites a few functions of scipy.integrate.ode”””</p>

<pre><code>def __init__(self,f,jac=None):

    def f2(t,y,args):
        return f(self.Y,t,*args)
    scipy.integrate.ode.__init__(self,f2,jac)
    self.set_f_params(None)

def integrate(self, t, step=0, relax=0):

    scipy.integrate.ode.integrate(self,t,step,relax)
    self.Y.update(self.t,self.y)
    return self.y

def set_initial_value(self,Y):

    self.Y = Y #!!! Y will be modified during integration
    scipy.integrate.ode.set_initial_value(self, Y(Y.tc), Y.tc)
</code></pre>

<p>def ddeint(func,g,tt,fargs=None):
    “”” similar to scipy.integrate.odeint. Solves the DDE system
        defined by func at the times tt with ‘history function’ g
        and potential additional arguments for the model, fargs
    “””</p>

<pre><code>dde_ = dde(func)
dde_.set_initial_value(ddeVar(g,tt[0]))
dde_.set_f_params(fargs if fargs else [])
return np.array([g(tt[0])]+[dde_.integrate(dde_.t + dt)
                             for dt in np.diff(tt)]) [/sourcecode]
</code></pre>

<p>&lt;/div&gt;</p>
<h2>Other implementations</h2>
<p>If you need a faster or more reliable implementation, have a look at the packages <strong>pyDDE</strong> and <strong>pydelay</strong>, which seem both very serious but are less friendly in their syntax.</p>
]]></content>
  </entry>
  
</feed>
