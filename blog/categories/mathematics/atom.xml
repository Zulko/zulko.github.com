<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mathematics | __del__( self )]]></title>
  <link href="http://Zulko.github.io/blog/categories/mathematics/atom.xml" rel="self"/>
  <link href="http://Zulko.github.io/"/>
  <updated>2014-06-09T14:19:10+02:00</updated>
  <id>http://Zulko.github.io/</id>
  <author>
    <name><![CDATA[Zulko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Viennese Mazes: what they are, and how to make one]]></title>
    <link href="http://Zulko.github.io/blog/2014/04/27/viennese-mazes-what-they-are/"/>
    <updated>2014-04-27T23:34:00+02:00</updated>
    <id>http://Zulko.github.io/blog/2014/04/27/viennese-mazes-what-they-are</id>
    <content type="html"><![CDATA[<p><em>In this post I present an original concept of labyrinths and explain how they can be programmatically generated.</em></p>

<!-- more -->

<p>For some time now I have been designing labyrinths based on traffic lights, like this one:</p>

<p>{% img center /images/vmazes/viennese_maze.jpeg 550 %}</p>

<p>I call these <em>Viennese mazes</em> (long story) and since I couldn’t find anything similar on the Web, I assume that this is something new. Here are <a href="https://i.imgur.com/j2gWurM.jpg">some more</a> with other shapes, and <a href="https://i.imgur.com/bReTSfN.png">their solutions</a>.</p>

<p>These mazes are very difficult to design by hand, and this post is about how to ask your computer to do the work for you. We will see what a <em>good</em> Viennese maze is made of, and how to generate one using a simple evolutionary algorithm.</p>

<h2 id="viennese-mazes-are-a-special-kind-of-normal-mazes">Viennese mazes are (a special kind of) normal mazes</h2>

<p>My first intention with Viennese mazes was to make dynamic mazes, with <em>moving walls</em>. But under each Viennese maze there is actually a standard, old-school labyrinth.</p>

<p>To see this we must think in terms of <em>states</em>. A state describes where you are in the maze, and determines where you can go from there. In the maze above, state (c,1,a) means “I am in (c), I have passed 1 traffic light until then, and just before that I was in (a)”. From this state you cannot reach (d) as the light in this street has turned red, and you cannot reach (a) because you just came from here. But you can move to (b) or (g), that is, to state (b,2,c) or state (g,2,c). Note that states such as (c,1,a), (c,4,a), and (c,7,a) are actually the same state, because afer three moves all traffic lights come back to their original position. So there will always be a finite number of states in a Viennese maze.</p>

<p>If we draw a map of all (reachable) states and their connexions we obtain the following <em>states graph</em> :</p>

<p>{% img center /images/vmazes/graph.jpeg %}</p>

<p>The green node marks the starting point, while the blue node is a reunion of all states corresponding to the goal (m). The nodes on the $i$-th line from the top can be reached in $i$ moves but no less, thick lines go downwards and thin lines go upwards.</p>

<p>This graph looks like a classical labyrinth, with crossroads, dead ends, loops… at one glance it gives an idea of the complexity and interestingness of the original Viennese maze. Therefore, we will consider that a good Viennese maze is a maze whose states graph makes a good labyrinth.</p>

<h2 id="what-makes-a-good-labyrinth-">What makes a good labyrinth ?</h2>

<p>Here is an illustration of a few criteria which make a labyrinth insteresting :</p>

<p>{% img center /images/vmazes/classical_maze.jpeg 450 %}</p>

<ol>
  <li><strong>There must be a unique solution, the longer the better.</strong> In Viennese mazes It will be difficult to avoid loops like the one in <em>a</em>, where you leave the right track at some point and join it back later at exactly the same position. But there should be a unique mandatory path to the goal (in red in the drawing).</li>
  <li><strong>There must be plenty of loops and dead ends</strong>, like in <em>b</em> and <em>c</em>, and also links between false paths (like <em>d</em>), all of these preferally early on the path.</li>
  <li><strong>The maze should be difficult to solve backwards</strong>, by having false ending paths (like <em>e</em>). This criterion also tends to produce nicer-looking Viennese mazes, with a better balance of the different colors.</li>
</ol>

<p>For the computer to be able to compare mazes and identify the most interesting ones we define scores <script type="math/tex"> S_1, S_2, S_3 </script> which will quantify how well each of the criteria 1,2,3, are fullfilled by a given maze. For instance</p>

<script type="math/tex; mode=display">
S_1(maze) =
\begin{cases}
0, \,\, \mbox{if there is no solution,} \\
1, \,\, \mbox{if there are multiple solutions,} \\
L, \,\, \mbox{if there is a unique solution, of length $L$.}
\end{cases}
</script>

<p>The final score of a Viennese maze is given by the product</p>

<script type="math/tex; mode=display"> S = S_1^{c_1} \cdot S_2^{c_2} \cdot S_3^{c_3} </script>

<p>where the exponents <script type="math/tex"> c_1, c_2, c_3 </script> reflect the relative importance that we decide to attach to each criterion.</p>

<p>Evaluating this score on the states graph of a Viennese maze is easy: the existence and uniqueness of a solution can be checked using a simple-path-finding algorithm. Dead-ends are simply the nodes of the states graph with no descendents, and the loops of the maze correspond to the thin edges. The states graph itself and its different lines of nodes can be easily computed using Dijkstra’s efficient algorithm to find minimal paths between the start and the different states. The current Python implementation, relying on the Networkx package, enable to evaluate on the order of 1000 mazes per second (depending on their complexity).</p>

<h2 id="lets-grow-mazes-">Let’s grow mazes !</h2>

<p>Now that we have defined how to score a Viennese maze, we will provide the computer with an uncolored canvas, and we will ask for a <em>coloring</em> (initial color of each traffic light) of this canvas that produces the best score possible :</p>

<p>{% img center /images/vmazes/canvas.jpeg 250 %}</p>

<p>There are $3^{24}$ (almost three hundred billion) ways of coloring the 24 streets on this canvas, and considering all of them would be too long. But a great many of these colorings make interesting mazes, so we can just look semi-randomly for some of these.</p>

<p>An effective way to do so is to first colorize the canvas in a completely random way, then improve the coloring by repeating the following steps:</p>

<ol>
  <li>Create a new maze by randomly changing just a few colors of the current maze.</li>
  <li>Compute the score of this new maze.</li>
  <li>If the new maze scores lower than the current maze, dump it, otherwise it replaces the current maze. Go back to step 1.</li>
</ol>

<p>Here is a maze being optimized following this mutation/selection procedure (over 24000 mazes were generated, only the successive improvements are shown):</p>

<p>{% img center http://i.imgur.com/yc1lwgh.gif ‘hosted on imgur’ %}</p>

<p>This algorithm can be refined using annealing (in which you first evaluate many different mazes before refining the search around the best one), or any fancier search strategy such as genetic algorithms, ant colonies… What works best is still an open question.</p>

<h2 id="try-it-at-home">Try it at home</h2>

<p>If you want to try and make your own Viennese mazes (using for instance you district as a canvas), I wrote a Python package called <a href="http://zulko.github.io/vmfactory/">vmfactory</a> which implements all the steps discussed above. It can generate two variants of Viennese mazes: one where passing through the same light twice in a row is forbidden, and one where it isn’t (algorithmically, the only difference is the way the states graph is computed).</p>

<p>In the following example, we generate a squared canvas, we initialize a maze with random colors, optimize it, and generate a report (maze/graph/solution): </p>

<p>{% codeblock lang:python %}
from vmfactory import Vmaze_NHT
from vmfactory.canvas import squares_grid</p>

<p>canvas = squares_grid(4,4) # nodes will be numbered 0..15
# NHT means no half-turns (can’t pass a light twice in a row) 
maze = Vmaze_NHT(canvas, start = 0, goal = 15)
maze.colorize( maze.random_colors() )
maze.anneal(200,20) # optimize the maze
maze.make_report().savefig(‘myreport.png’)
{% endcodeblock %}</p>

<p>{% img center /images/vmazes/report.jpeg 550 %}</p>

<p>The package is based on Networkx, Numpy and Matplotlib. The code is rather short (most of it serves to draw fancy graphs !), and modular : you can easily change the rules, change the way the score is computed, change the optimization procedure, or the way the reports are drawn.</p>

<p>Thank you for reading until there, and happy mazing !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Delay differential equations in Python]]></title>
    <link href="http://Zulko.github.io/blog/2013/10/22/delay-differential-equations-in-python/"/>
    <updated>2013-10-22T07:50:00+02:00</updated>
    <id>http://Zulko.github.io/blog/2013/10/22/delay-differential-equations-in-python</id>
    <content type="html"><![CDATA[<p><em>I wrote</em> <a href="https://github.com/Zulko/ddeint">ddeint</a>, <em>a simple module/function for solving Delay Differential Equations (DDEs) in Python. It is not very fast, but very flexible, and coded in just <a href="https://gist.github.com/Zulko/7096011">a few lines</a> on top of Scipy’s differential equations solver,</em> <code>odeint</code>.</p>

<!-- more -->

<p>Say you have a delay differential equation like this:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{cases}
y(t) = g(t), \,\,\,\, &\mbox{for $t<0$} \\
y'(t) = F( y, t), \,\,\,\, &\mbox{for $t \geq 0$},
\end{cases}
 %]]&gt;</script>

<p>where $F(y, t)$ can involve delayed values of $y$, of the form $y(t-d)$.</p>

<p>To solve this DDE system at points <code>t=[t1, t2 ...]</code> you would just write</p>

<p>{% codeblock lang:python %}
y = ddeint(F, g, t) # returns [y(t1), y(t2) …]
{% endcodeblock %}</p>

<h2 id="a-simple-example">A simple example</h2>

<p>Let us start with a DDE whose exact solution is known (it is the sine function), just to check that the algorithm works as expected:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{cases}
y(t) = \sin(t), \,\,\,\, &\mbox{for $t<0$} \\ 
y'(t) = y(t-3\pi/2), \,\,\,\, &\mbox{for $t \geq 0$}
\end{cases}
 %]]&gt;</script>

<p>Here is how we solve it with <code>ddeint</code>:</p>

<p>{% codeblock lang:python %}
from pylab import *
from ddeint import ddeint</p>

<p>model = lambda Y,t : Y(t - 3*pi/2) # Model
tt = linspace(0,50,10000) # Time start, time end, nb of points/steps
g=sin # Expression of Y(t) before the integration interval
yy = ddeint(model,g,tt) # Solving</p>

<h1 id="plotting">PLOTTING</h1>
<p>plot(tt,yy,c=’r’,label=”$y(t)$”)
plot(tt,sin(tt),c=’b’,label=”$sin(t)$”)
set_ylim(ymax=2) # make room for the legend
legend()
{% endcodeblock %}</p>

<p>{% img center /images/ddeint/dde_sin.jpeg %}</p>

<p>The resulting plot compares our solution (red) with the exact solution (blue). See how our result eventually detaches itself from the actual solution as a consequence of many successive approximations ? As DDEs tend to create chaotic behaviors, you can expect the error to explode very fast. As I am no DDE expert, I would recommend checking for convergence in all cases, i.e. increasing the time resolution and see how it affects the result. Keep in mind that the past values of Y(t) are computed by interpolating the values of Y found at the previous integration points, so the more points you ask for, the more precise your result.</p>

<h2 id="an-example-with-parameters">An example with parameters</h2>

<p>You can set the parameters of your model at integration time, like in Scipy’s <code>ODE</code> and <code>odeint</code>. As an example, imagine a chemical product with degradation rate $r$, and whose production rate is negatively linked to the quantity of this same product at the time $(t-d)$:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{cases}
y(t) = 0, \,\,\,\, &\mbox{for $t<0$} \\
y'(t) = \dfrac{1}{1+(\dfrac{y(t-d)}{K})^2} -ry(t), \,\,\,\,
&\mbox{ for $t\geq 0$}.
\end{cases}
 %]]&gt;</script>

<p>We have three parameters that we can choose freely. For $K = 0.1$, $d = 5$, $r = 1$, we obtain oscillations !</p>

<p>{% codeblock lang:python %}
# MODEL, WITH UNKNOWN PARAMETERS
model = lambda Y,t, k,d,r :  1/(1+(Y(t-d)/k)<em>*2) - r</em>Y(t)
g = lambda t:0 # history before t=0</p>

<p>tt = linspace(0,50,10000)
yy = ddeint(model, g, tt, fargs=(0.1, 5, 1)) # K=0.1, d=5, r=1</p>

<p>plot(tt,yy,lw=2)
{% endcodeblock %}</p>

<p>{% img center /images/ddeint/dde_negativefeedback.jpeg %}</p>

<h2 id="example-with-several-variables">Example with several variables</h2>

<p>The variable Y can be a vector, which means that you can solve DDE 
systems of several variables. Here is a version of the famous 
Lotka-Volterra two-variables system, where we introduce a delay $d$. 
For $d=0$ the system is a classical Lotka-Volterra system ; for 
$d\neq 0$ the system undergoes an important amplification:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{cases}
\big(x(t), y(t)\big) = (1,2) \,\,\,\, &\mbox{for $t<0$}, \\
x'(t) = 0.5x(t)\big(1-y(t-d)\big) \,\,\,\, &\mbox{for $t\geq 0$}, \\
y'(t) = -0.5y(t)\big(1-x(t-d)\big) \,\,\,\, &\mbox{for $\geq 0$}.
\end{cases}
 %]]&gt;</script>

<p>{% codeblock lang:python %}
def model(Y,t,d):
    x,y = Y(t)
    xd,yd = Y(t-d)
    return array([0.5<em>x</em>(1-yd), -0.5<em>y</em>(1-xd)])</p>

<p>g = lambda t : array([1,2])
tt = linspace(2,30,20000)</p>

<p>for d in [0, 0.2]:
    yy = ddeint(model,g,tt,fargs=(d,))
    # WE PLOT X AGAINST Y
    plot(yy[:,0], yy[:,1], lw=2, label=’delay = %.01f’%d)</p>

<p>legend() # display the legend
{% endcodeblock %}</p>

<p>{% img center /images/ddeint/dde_lotka.jpeg %}</p>

<h2 id="example-with-a-non-constant-delay">Example with a non-constant delay</h2>

<p>In this last example the delay depends on the value of $y(t)$ :</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{cases}
y(t) = 1, \,\,\,\, &\mbox{for $t<0$}, \\
y'(t) = - y\big(t-3\cos(y(t))^2 \big),\,\,\,\,
&\mbox{for $t \geq 0$}.
\end{cases}
 %]]&gt;</script>

<p>{% codeblock lang:python %}
model = lambda Y,t:  -Y( t-3*cos( Y(t) )**2 )
tt = linspace(0, 30, 2000)
yy = ddeint(model, lambda t:1, tt)</p>

<p>plot(tt, yy)
{% endcodeblock %}</p>

<p>{% img center /images/ddeint/ydependent.jpeg %}</p>
]]></content>
  </entry>
  
</feed>
